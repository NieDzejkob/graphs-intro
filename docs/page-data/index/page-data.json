{"componentChunkName":"component---gatsby-theme-mdx-deck-src-templates-deck-js","path":"/","matchPath":"/*","result":{"data":{"deck":{"id":"ebd3cca4-6d1f-5c1f-a266-cc08803086b2","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar theme = vsDark;\nvar _frontmatter = {};\nvar layoutProps = {\n  theme: theme,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Grafy\"), mdx(\"p\", null, \"Wprowadzenie\"), mdx(\"hr\", null), mdx(GraphAnimation, {\n    graph: makeGraph([[1, 2], [2, 3], [1, 5], [2, 5], [3, 4], [4, 5], [4, 6], [3, 9, 'shadow'], [9, 8], [8, 7], [4, 7, ['shadow', 'long']]]),\n    steps: function steps(g) {\n      return [['reset'], ['addLabel', ['wierzchołek', 'above', 5]], ['addLabel', ['krawędź', 'right', 4, 6]], ['makeDirected', true], ['combo', ['resetLabels'], ['makeDirected', false], ['setWeights', [1, 5, 3], [2, 5, 7], [1, 2, 12], [2, 3, 6], [5, 4, 10], [3, 4, 8], [4, 6, 8], [7, 8, 7], [8, 9, 12]]], ['addLabel', ['waga', 'right', 3, 4]]];\n    },\n    mdxType: \"GraphAnimation\"\n  }), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"title=\\\"Reprezentowanie grafów\\\"\",\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Macierz sąsiedztwa\\\"\",\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Macierz\",\n    \"sąsiedztwa\\\"\": true\n  }), \"bool edges[N][N];\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Macierz sąsiedztwa\\\"\",\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Macierz\",\n    \"sąsiedztwa\\\"\": true\n  }), \"bool edges[N][N];\\nbool connected(int a, int b) {\\n    return edges[a][b];\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Macierz sąsiedztwa\\\"\",\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Macierz\",\n    \"sąsiedztwa\\\"\": true\n  }), \"bool edges[N][N];\\nbool connected(int a, int b) {\\n    return edges[a][b];\\n}\\n\\nvoid add_edge(int a, int b) {\\n    edges[a][b] = true;\\n    edges[b][a] = true;\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Macierz sąsiedztwa\\\"\",\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Macierz\",\n    \"sąsiedztwa\\\"\": true\n  }), \"bool edges[N][N];\\nbool connected(int a, int b) {\\n    return edges[a][b];\\n}\\n\\nvoid add_edge(int a, int b) {\\n    edges[a][b] = true;\\n    edges[b][a] = true;\\n}\\n\\nvoid for_each_edge(int a) {\\n    for (int b = 0; b < N; b++) {\\n        if (!edges[a][b]) continue;\\n        // ...\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"1[11:16] title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Macierz sąsiedztwa\\\"\",\n    \"1[11:16]\": true,\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Macierz\",\n    \"sąsiedztwa\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Macierz sąsiedztwa\\\"\",\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Macierz\",\n    \"sąsiedztwa\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"1:15 title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Macierz sąsiedztwa (graf skierowany)\\\"\",\n    \"1:15\": true,\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Macierz\",\n    \"sąsiedztwa\": true,\n    \"(graf\": true,\n    \"skierowany)\\\"\": true\n  }), \"bool edges[N][N];\\nbool connected(int a, int b) {\\n    return edges[a][b];\\n}\\n\\nvoid add_edge(int a, int b) {\\n    edges[a][b] = true;\\n}\\n\\nvoid for_each_outgoing_edge(int a) {\\n    for (int b = 0; b < N; b++) {\\n        if (!edges[a][b]) continue;\\n        // ...\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"1[1:3] title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Macierz sąsiedztwa (graf ważony)\\\"\",\n    \"1[1:3]\": true,\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Macierz\",\n    \"sąsiedztwa\": true,\n    \"(graf\": true,\n    \"ważony)\\\"\": true\n  }), \"int edges[N][N];\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"1[1:13] title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Macierz sąsiedztwa (graf ważony)\\\"\",\n    \"1[1:13]\": true,\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Macierz\",\n    \"sąsiedztwa\": true,\n    \"(graf\": true,\n    \"ważony)\\\"\": true\n  }), \"optional<int> edges[N][N];\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Listy sąsiedztwa\\\"\",\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Listy\",\n    \"sąsiedztwa\\\"\": true\n  }), \"vector<vector<int>> edges;\\nedges.resize(N);\\n\\nvoid add_edge(int a, int b) {\\n    edges[a].push_back(b);\\n    edges[b].push_back(a);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Listy sąsiedztwa\\\"\",\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Listy\",\n    \"sąsiedztwa\\\"\": true\n  }), \"vector<vector<int>> edges;\\nedges.resize(N);\\n\\nvoid add_edge(int a, int b) {\\n    edges[a].push_back(b);\\n    edges[b].push_back(a);\\n}\\n\\nvoid for_each_edge(int a) {\\n    for (int b : edges[a]) {\\n        // ...\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Listy sąsiedztwa\\\"\",\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Listy\",\n    \"sąsiedztwa\\\"\": true\n  }), \"vector<vector<int>> edges;\\nedges.resize(N);\\n\\nbool connected(int a, int b) {\\n    for (int neighbour : edges[a]) {\\n        if (neighbour == b) return true;\\n    }\\n\\n    return false;\\n}\\n\\nvoid add_edge(int a, int b) {\\n    edges[a].push_back(b);\\n    edges[b].push_back(a);\\n}\\n\\nvoid for_each_edge(int a) {\\n    for (int b : edges[a]) {\\n        // ...\\n    }\\n}\\n\"))), mdx(\"hr\", null), mdx(GraphAnimation, {\n    noNames: true,\n    graph: makeGraph([[0, 1, 'long'], [0, 2, 'long'], [0, 3, 'long'], [0, 4, 'long'], [0, 5, 'long'], [0, 6, 'long'], [0, 7, 'long'], [0, 8, 'long'], [0, 9, 'long'], [0, 10, 'long'], [0, 11, 'long'], [0, 12, 'long'], [0, 13, 'long'], [0, 14, 'long'], [0, 15, 'long'], [0, 16, 'long'], [0, 17, 'long'], [0, 18, 'long'], [0, 19, 'long'], [0, 20, 'long']]),\n    steps: function steps(g) {\n      return [['reset', [['blue', 0]], [['blue', 0, 1]], [['blue', 1]]]];\n    },\n    mdxType: \"GraphAnimation\"\n  }), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"4:10 title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Listy sąsiedztwa\\\"\",\n    \"4:10\": true,\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Listy\",\n    \"sąsiedztwa\\\"\": true\n  }), \"vector<vector<int>> edges;\\nedges.resize(N);\\n\\nbool connected(int a, int b) {\\n    for (int neighbour : edges[a]) {\\n        if (neighbour == b) return true;\\n    }\\n\\n    return false;\\n}\\n\\nvoid add_edge(int a, int b) {\\n    edges[a].push_back(b);\\n    edges[b].push_back(a);\\n}\\n\\nvoid for_each_edge(int a) {\\n    for (int b : edges[a]) {\\n        // ...\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Listy sąsiedztwa\\\"\",\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Listy\",\n    \"sąsiedztwa\\\"\": true\n  }), \"vector<vector<int>> edges;\\nedges.resize(N);\\n\\nbool connected(int a, int b) {\\n    if (edges[b].size() < edges[a].size())\\n        swap(a, b);\\n    for (int neighbour : edges[a]) {\\n        if (neighbour == b) return true;\\n    }\\n\\n    return false;\\n}\\n\\nvoid add_edge(int a, int b) {\\n    edges[a].push_back(b);\\n    edges[b].push_back(a);\\n}\\n\\nvoid for_each_edge(int a) {\\n    for (int b : edges[a]) {\\n        // ...\\n    }\\n}\\n\"))), mdx(\"hr\", null), mdx(GraphAnimation, {\n    noNames: true,\n    graph: makeGraph([[0, 1, 'long'], [0, 2, 'long'], [1, 3, 'long'], [0, 4, 'long'], [1, 5, 'long'], [0, 6, 'long'], [1, 7, 'long'], [0, 8, 'long'], [1, 9, 'long'], [0, 10, 'long'], [1, 11, 'long'], [0, 12, 'long'], [1, 13, 'long'], [0, 14, 'long'], [1, 15, 'long'], [0, 16, 'long'], [1, 17, 'long'], [0, 18, 'long'], [1, 19, 'long'], [0, 20, 'long'], [1, 102, 'long'], [0, 103, 'long'], [1, 104, 'long'], [0, 105, 'long'], [1, 106, 'long'], [0, 107, 'long'], [1, 108, 'long'], [0, 109, 'long'], [1, 110, 'long'], [0, 111, 'long'], [1, 112, 'long'], [0, 113, 'long'], [1, 114, 'long'], [0, 115, 'long'], [1, 116, 'long'], [0, 117, 'long'], [1, 118, 'long'], [0, 119, 'long'], [1, 120, 'long']]),\n    steps: function steps(g) {\n      return [['reset', [['blue', 0]], [['blue', 0, 1]], [['blue', 1]]]];\n    },\n    mdxType: \"GraphAnimation\"\n  }), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Listy sąsiedztwa\\\" 1[8:15]\",\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Listy\",\n    \"sąsiedztwa\\\"\": true,\n    \"1[8:15]\": true\n  }), \"vector<set<int>> edges;\\nedges.resize(N);\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Listy sąsiedztwa\\\"\",\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Listy\",\n    \"sąsiedztwa\\\"\": true\n  }), \"vector<set<int>> edges;\\nedges.resize(N);\\n\\nbool connected(int a, int b) {\\n    return edges[a].count(b);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"1[8:20] title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Listy sąsiedztwa (graf ważony)\\\"\",\n    \"1[8:20]\": true,\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Listy\",\n    \"sąsiedztwa\": true,\n    \"(graf\": true,\n    \"ważony)\\\"\": true\n  }), \"vector<map<int, int>> edges;\\nedges.resize(N);\\n\\nbool connected(int a, int b) {\\n    return edges[a].count(b);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"title=\\\"Reprezentowanie grafów\\\" subtitle=\\\"Listy sąsiedztwa (graf skierowany)\\\"\",\n    \"title\": \"\\\"Reprezentowanie\",\n    \"grafów\\\"\": true,\n    \"subtitle\": \"\\\"Listy\",\n    \"sąsiedztwa\": true,\n    \"(graf\": true,\n    \"skierowany)\\\"\": true\n  }), \"vector<set<int>> edgesFrom;\\nvector<set<int>> edgesTo;\\n\"))), mdx(\"hr\", null), mdx(GraphAnimation, {\n    noNames: true,\n    graph: makeMaze(27, 17),\n    steps: function steps(g) {\n      return [['reset', [['hide', 'shadow1'], ['hide', 'shadow2'], ['hide', 'shadow3']]]];\n    },\n    mdxType: \"GraphAnimation\"\n  }), mdx(\"hr\", null), mdx(GraphAnimation, {\n    graph: makeGraph([[1, 2], [2, 3], [1, 5], [5, 2], [3, 4], [4, 5], [4, 6], [3, 9, 'shadow'], [9, 8], [8, 7], [4, 7, ['shadow', 'long']]]),\n    steps: function steps(g) {\n      return [['makeDirected', true], ['add', [['blue', 2], ['blue', 2, 3, 'arrow']], [['blue', 3], ['blue', 3, 4, 'arrow']], [['blue', 4], ['blue', 4, 5, 'arrow']], [['blue', 5], ['blue', 5, 2, 'arrow']]], ['addLabel', ['cykl', 'right', 3, 4]], ['combo', ['resetLabels'], ['reset'].concat(dfs(g, 1))]];\n    },\n    mdxType: \"GraphAnimation\"\n  }), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"bool seen[N];\\nvoid dfs(int a) {\\n    seen[a] = true;\\n    for (int b : edgesFrom[a]) {\\n        if (!seen[b]) dfs(b);\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"10\": true,\n    \"className\": \"language-cpp\",\n    \"metastring\": \"10\"\n  }), \"bool seen[N];\\nvoid dfs(int a) {\\n    seen[a] = true;\\n    for (int b : edgesFrom[a]) {\\n        if (!seen[b]) dfs(b);\\n    }\\n}\\n\\ndfs(a);\\nfor (bool& x : seen) x = false;\\ndfs(b);\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"1[1:3],2,4[15:19],6[13:28],11\",\n    \"1[1:3],2,4[15:19],6[13:28],11\": true\n  }), \"int seen[N];\\nint epoch = 1;\\nvoid dfs(int a) {\\n    seen[a] = epoch;\\n    for (int b : edgesFrom[a]) {\\n        if (seen[b] != epoch) dfs(b);\\n    }\\n}\\n\\ndfs(a);\\nepoch++;\\ndfs(b);\\n\"))), mdx(\"hr\", null), mdx(\"h1\", null, \"Czas na zadanie\"), mdx(\"h2\", null, \"2137.pl/cTMLam\"), mdx(\"hr\", null), mdx(GraphAnimation, {\n    directed: true,\n    graph: makeGraph([[4, 7], [7, 3], [3, 6], [6, 2], [2, 4], [5, 6], [1, 5]]),\n    steps: function steps(g) {\n      return [['setComment', mdx(\"tspan\", {\n        style: {\n          fontSize: 20,\n          fill: \"#9cdcfe\"\n        }\n      }, \"2137.pl/cTMLam\")], ['add', [['corner', 4, 5], ['corner', 7, 5], ['corner', 3, 5], ['corner', 6, 5], ['corner', 2, 5], ['corner', 5, 6], ['corner', 1, 7]]]];\n    },\n    mdxType: \"GraphAnimation\"\n  }), mdx(\"hr\", null), mdx(\"h1\", null, \"Forwarding Emails\"), mdx(\"h2\", null, \"2137.pl/cTMLam\"), mdx(\"hr\", null), mdx(GraphAnimation, {\n    directed: true,\n    graph: makeGraph([[4, 7], [7, 3], [3, 6], [6, 2], [2, 4], [5, 6], [1, 5], [1, 2, ['long', 'shadow']], [8, 4], [9, 10], [10, 11], [11, 9], [11, 2, ['long', 'shadow']], [12, 10], [2, 3, 'shadow']]),\n    steps: function steps(g) {\n      return [['reset'], ['add', [['convexHull', 1, 2, 3, 4, 5, 6, 7, 8], ['convexHull', 9, 10, 11, 12]]], ['reset'], ['add', [['orange', 2], ['orange', 4], ['orange', 7], ['orange', 3], ['orange', 6], ['orange', 2, 4, 'arrow'], ['orange', 4, 7, 'arrow'], ['orange', 7, 3, 'arrow'], ['orange', 3, 6, 'arrow'], ['orange', 6, 2, 'arrow'], ['orange', 9], ['orange', 10], ['orange', 11], ['orange', 9, 10, 'arrow'], ['orange', 10, 11, 'arrow'], ['orange', 11, 9, 'arrow']]], ['add', [['green', 12], ['green', 12, 10, 'arrow'], ['green', 1, 5, 'arrow'], ['green', 5, 6, 'arrow'], ['green', 8, 4, 'arrow'], ['green', 1], ['green', 5], ['green', 8]]], ['reset'].concat(dfs(g, 1, {\n        3: 1,\n        7: 2,\n        4: 3,\n        2: 4,\n        6: 5,\n        5: 6,\n        1: 7\n      })), ['add', [['convexHull', 'green', 1, 5, 6]]], ['replace', [['convexHull', 'red', 3, 7, 2, 4]]]].concat(function () {\n        var anim = dfs(g, 1, {\n          3: 5,\n          7: 5,\n          4: 5,\n          2: 5,\n          6: 5,\n          5: 6,\n          1: 7\n        }, {\n          1: '(1)',\n          5: '(2)',\n          6: '(3)',\n          2: '(4)',\n          4: '(5)',\n          7: '(6)',\n          3: '(7)'\n        });\n        var i = anim.findIndex(function (step) {\n          return step.some(function (c) {\n            return c[0] === 'red';\n          });\n        }) + 1;\n        var _ref2 = [anim.slice(0, i), anim.slice(i)],\n            before = _ref2[0],\n            after = _ref2[1];\n        return [['reset'].concat(before), ['add', [['corner', 6, '(3) (8)']]], ['add'].concat(after)];\n      }());\n    },\n    mdxType: \"GraphAnimation\"\n  }), mdx(\"hr\", null), mdx(\"div\", {\n    style: {\n      display: \"flex\",\n      flexDirection: \"row\",\n      width: \"100%\",\n      height: \"100%\"\n    }\n  }, mdx(\"div\", {\n    style: {\n      display: \"block\",\n      height: \"100%\",\n      width: \"50%\"\n    }\n  }, mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"file=\\\"forwarding-emails.cpp\\\"\",\n    \"file\": \"\\\"forwarding-emails.cpp\\\"\"\n  }), \"#include <iostream>\\nusing namespace std;\\n\\nint T, N;\\n\\nint edge[50001];\\nint counts[50001];\\n\\n// returns true if in cycle\\nbool dfs(int n, int t) {\\n    if (counts[n]) return false;\\n    counts[n] = -t;\\n    int e = edge[n];\\n    if (counts[e] < 0) {\\n        counts[e] += t + 1;\\n        counts[n] = counts[e];\\n        return true;\\n    } else if (dfs(e, t + 1)) {\\n        if (counts[n] > 0) {\\n            return false;\\n        } else {\\n            counts[n] = counts[e];\\n            return true;\\n        }\\n    } else {\\n        counts[n] = counts[e] + 1;\\n        return false;\\n    }\\n}\\n\\nint main() {\\n    ios::sync_with_stdio(false); cin.tie();\\n\\n    cin >> T;\\n    for (int t = 1; t <= T; t++) {\\n        cin >> N;\\n        for (int i = 1; i <= N; i++) {\\n            int a, b;\\n            cin >> a >> b;\\n            edge[a] = b;\\n            counts[i] = 0;\\n        }\\n\\n        int best = 0;\\n        int bestpos = 0;\\n\\n        for (int i = 1; i <= N; i++) {\\n            dfs(i, 1);\\n            if (counts[i] > best) {\\n                best = counts[i];\\n                bestpos = i;\\n            }\\n        }\\n\\n        cout << \\\"Case \\\" << t << \\\": \\\" << bestpos << \\\"\\\\n\\\";\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"6\": true,\n    \"className\": \"language-diff\",\n    \"metastring\": \"6\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"38:40\",\n    \"38:40\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"7\": true,\n    \"className\": \"language-diff\",\n    \"metastring\": \"7\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"12,10[17:21],18[23:27]\",\n    \"12,10[17:21],18[23:27]\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"13:17\",\n    \"13:17\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"13:17\",\n    \"13:17\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"18,21:24\",\n    \"18,21:24\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"19,20\",\n    \"19,20\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"25:27\",\n    \"25:27\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"9:29\",\n    \"9:29\": true\n  }), \"\")))), mdx(\"div\", {\n    style: {\n      display: \"block\",\n      height: \"100%\",\n      width: \"50%\",\n      background: \"#f6f8fa\"\n    }\n  }, mdx(GraphAnimation, {\n    color: \"black\",\n    directed: true,\n    graph: makeGraph([[1, 2], [2, 3], [3, 4], [4, 5], [5, 1], [6, 2], [7, 6]]),\n    steps: function steps(g) {\n      return [['reset'], ['add'], ['add', [['green', 6, 2, 'arrow'], ['green', 2], ['green', 6], ['corner', 6, mdx(\"tspan\", {\n        style: {\n          fontFamily: 'monospace',\n          fill: 'green'\n        }\n      }, \"\\xA0edge[6] = 2;\")]]], ['reset'], ['add', [['corner', 7, -1], ['corner', 6, -2], ['corner', 2, -3], ['corner', 3, -4], ['corner', 4, -5], ['corner', 5, -6], ['corner', 1, -7]]], ['add', [['blue', 1], ['blue', 2], ['red', 1, 2, 'arrow']]], ['add', [['corner', 1, 5], ['corner', 2, 5]]], ['withCorners', [['blue', 5], ['blue', 1], ['blue', 5, 1, 'arrow']]], ['withCorners', [['corner', 5, 5], ['corner', 4, 5], ['corner', 3, 5], ['blue', 2], ['blue', 3], ['blue', 2, 3, 'arrow'], ['corner', 2, mdx(\"tspan\", {\n        dominantBaseline: \"hanging\",\n        fill: \"red\"\n      }, \"5\")]]], ['withCorners', [['blue', 6], ['blue', 2], ['blue', 6, 2, 'arrow'], ['corner', 2, 5], ['corner', 6, 6]]], ['withCorners', [['corner', 7, 7]]]];\n    },\n    mdxType: \"GraphAnimation\"\n  }))), mdx(\"hr\", null), mdx(GraphAnimation, {\n    graph: makeGraph([[1, 2], [2, 3], [1, 5], [2, 5], [3, 4], [4, 5], [4, 6], [3, 9, 'shadow'], [9, 8], [8, 7], [4, 7, ['shadow', 'long']]]),\n    steps: function steps(g) {\n      return [['reset'], ['add', [['blue', 1]]].concat(animateLayers(g, 1, 'blue')), ['reset', [['blue', 1], ['blue', 2], ['blue', 1, 2], ['blue', 1, 5], ['blue', 2, 3], ['blue', 2, 5], ['orange', 5], ['orange', 3]]], ['add', [['blue', 3]]], ['add', [['blue', 3, 4], ['orange', 4]]]];\n    },\n    mdxType: \"GraphAnimation\"\n  }), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"bool seen[N];\\nvoid bfs(int a) {\\n    queue<int> q; q.push(a);\\n    seen[a] = true;\\n    while (!q.empty()) {\\n        a = q.front(); q.pop();\\n        for (int b : edges[a]) {\\n            if (seen[b]) continue;\\n            seen[b] = true;\\n            q.push(b);\\n        }\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"3:4\",\n    \"3:4\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"5\": true,\n    \"className\": \"language-diff\",\n    \"metastring\": \"5\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"6:7\",\n    \"6:7\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"8\": true,\n    \"className\": \"language-diff\",\n    \"metastring\": \"8\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"10\": true,\n    \"className\": \"language-diff\",\n    \"metastring\": \"10\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"9\": true,\n    \"className\": \"language-diff\",\n    \"metastring\": \"9\"\n  }), \"\"))), mdx(\"hr\", null), mdx(\"h1\", null, \"The Net\"), mdx(\"h2\", null, \"2137.pl/VGfGvN\"), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"1\": true,\n    \"className\": \"language-cpp\",\n    \"metastring\": \"1\"\n  }), \"bool seen[N];\\nvoid bfs(int a) {\\n    queue<int> q; q.push(a);\\n    seen[a] = true;\\n    while (!q.empty()) {\\n        a = q.front(); q.pop();\\n        for (int b : edges[a]) {\\n            if (seen[b]) continue;\\n            seen[b] = true;\\n            q.push(b);\\n        }\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"1,4,9\",\n    \"1,4,9\": true\n  }), \"int prev[301];\\nvoid bfs(int a) {\\n    queue<int> q; q.push(a);\\n    prev[a] = a;\\n    while (!q.empty()) {\\n        a = q.front(); q.pop();\\n        for (int b : edgesTo[a]) {\\n            if (prev[b]) continue;\\n            prev[b] = a;\\n            q.push(b);\\n        }\\n    }\\n}\\n\\nint main() {\\n    std::ios::sync_with_stdio(false); cin.tie();\\n    int n;\\n    while (cin >> n) {\\n        cout << \\\"-----\\\\n\\\";\\n        edgesTo.clear();\\n        edgesTo.resize(n+1);\\n        for (int i = 0; i < n; i++) {\\n            int a; cin >> a;\\n            char c; cin >> c;\\n            if (cin.peek() == '\\\\n') continue;\\n            while(1) {\\n                int b; cin >> b;\\n                edgesTo[b].push_back(a);\\n                if (cin.peek() == ',') cin >> c;\\n                else break;\\n            }\\n        }\\n        int q; cin >> q;\\n        while (q--) {\\n            int a, b; cin >> a >> b;\\n            for (int i = 0; i <= n; i++) prev[i] = 0;\\n            bfs(b);\\n            if (prev[a]) {\\n                while (a != b) {\\n                    cout << a << ' ';\\n                    a = prev[a];\\n                }\\n                cout << b << '\\\\n';\\n            } else {\\n                cout << \\\"connection impossible\\\\n\\\";\\n            }\\n        }\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"35:46\",\n    \"35:46\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"1:49\",\n    \"1:49\": true\n  }), \"\"))), mdx(\"hr\", null), mdx(GraphAnimation, {\n    graph: makeGraph([[1, 2], [2, 3], [1, 5], [2, 5], [3, 4], [4, 5], [4, 6], [3, 9, 'shadow'], [9, 8], [8, 7], [4, 7, ['shadow', 'long']]]),\n    steps: function steps(g) {\n      return [['reset'], ['setWeights', [1, 5, 3], [2, 5, 7], [1, 2, 12], [2, 3, 6], [5, 4, 10], [3, 4, 8], [4, 6, 8], [7, 8, 7], [8, 9, 12]], ['setWeights'], ['add', [['convexHull', 1, 2, 3, 4, 5, 6], ['convexHull', 7, 8, 9]]], ['reset', [['blue', 1]]].concat(animateLayers(g, 1, 'blue')), ['add', [['orange', 7]]].concat(animateLayers(g, 7, 'orange'))];\n    },\n    mdxType: \"GraphAnimation\"\n  }), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"int ccID[N];\\nint numCC;\\nvoid dfs(int a) {\\n    ccID[a] = numCC;\\n    for (int b : edgesFrom[a]) {\\n        if (!ccID[b]) dfs(b);\\n    }\\n}\\n\\nvoid fillCCs() {\\n    for (int a = 0; a < N; a++) {\\n        if (!ccID[a]) {\\n            numCC++;\\n            dfs(a);\\n        }\\n    }\\n}\\n\"))), mdx(\"hr\", null), mdx(GraphAnimation, {\n    directed: true,\n    graph: makeGraph([[1, 2], [2, 3], [1, 5], [2, 5], [3, 4], [4, 5], [4, 6], [3, 9, 'shadow'], [9, 8], [8, 7], [4, 7, ['shadow', 'long']], [5, 3], [4, 2], [6, 1, ['shadow', 'longer']]]),\n    steps: function steps(g) {\n      return [['reset'], ['add', [['red', 6, 1, 'arrow']]], ['reset', [['convexHull', 'blue', 2, 3, 4, 5]]]];\n    },\n    mdxType: \"GraphAnimation\"\n  }), mdx(\"hr\", null), mdx(GraphAnimation, {\n    graph: makeGraph([[1, 2, 'shadow'], [2, 3, 'shadow'], [1, 5], [2, 5], [3, 4], [4, 5], [4, 6], [6, 7], [7, 8]], [6], 0.5),\n    steps: function steps(g) {\n      return [['reset'], ['addLabel', ['korzeń', 'left', 6]], ['add', [['blue', 5]]], ['addLabel', ['rodzic', 'left', 4]], ['combo', ['addLabel', ['dzieci', 'rightFar', 2]], ['add', [['convexHull', 1, 2]]]], ['combo', ['resetLabels'], ['addLabel', ['poddrzewo', 'leftFarther', 4]], ['reset', [['convexHull', 1, 2, 3, 4, 5]]]], ['combo', ['resetLabels'], ['reset', [['convexHull', 6]], [['convexHull', 4, 7]], [['convexHull', 8, 3, 5, 8]], [['convexHull', 1, 2]]]]];\n    },\n    mdxType: \"GraphAnimation\"\n  }), mdx(\"hr\", null), mdx(\"h1\", null, \"The Tree Root\"), mdx(\"h2\", null, \"2137.pl/VGAEuk\"), mdx(\"hr\", null), mdx(GraphAnimation, {\n    graph: makeGraph([[1, 2, 'shadow'], [2, 3, 'shadow'], [1, 5], [2, 5], [3, 4], [4, 5], [4, 6], [6, 7], [7, 8]], [6], 0.5),\n    steps: function steps(g) {\n      return [['reset'], ['add', [['blue', 4], ['green', 5], ['green', 3], ['green', 4, 5], ['green', 4, 3], ['corner', 3, mdx(\"tspan\", {\n        dominantBaseline: \"hanging\",\n        style: {\n          fontFamily: 'monospace'\n        }\n      }, \"h[4] = 1 + max(h[5], h[3])\")]]], ['reset', [['blue', 4], ['convexHull', 1, 2, 3, 4, 5]]], ['add', [['convexHull', 'hotfix', 6, 7, 8]]], ['reset', [['blue', 5]]], ['add', [['green', 4]]], ['add', [['convexHull', 'hotfix', 6, 7, 8]]], ['add', [['convexHull', 3]]]];\n    },\n    mdxType: \"GraphAnimation\"\n  }), mdx(\"hr\", null), mdx(GraphAnimation, {\n    noNames: true,\n    graph: makeGraph([[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [1, 8], [1, 9], [1, 10], [1, 11], [1, 12], [1, 13]], [1], 0.7),\n    steps: function steps(g) {\n      return [['reset']];\n    },\n    mdxType: \"GraphAnimation\"\n  }), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"vector<vector<int>> children;\\nint parent[5001];\\nint N;\\n\\nvoid rootify(int a) {\\n    auto it = find(children[a].begin(), children[a].end(), parent[a]);\\n    if (it != children[a].end()) {\\n        children[a].erase(it);\\n    }\\n\\n    for (int b : children[a]) {\\n        parent[b] = a;\\n        rootify(b);\\n    }\\n}\\n\\nint main() {\\n    while (cin >> N) {\\n        children.clear();\\n        children.resize(N + 1);\\n        for (int i = 0; i < N; i++) {\\n            int count; cin >> count;\\n            while (count--) {\\n                int a; cin >> a; a--;\\n                children[i].push_back(a);\\n            }\\n        }\\n\\n        parent[0] = 0;\\n        rootify(0);\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"6:9\",\n    \"6:9\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"11:14\",\n    \"11:14\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"vector<vector<int>> children;\\nint parent[5001];\\npair<int, int> highestSubtree[5001];\\nint N;\\n\\nvoid rootify(int a) {\\n    auto it = find(children[a].begin(), children[a].end(), parent[a]);\\n    if (it != children[a].end()) {\\n        children[a].erase(it);\\n    }\\n\\n    int h1 = 0, h2 = 0;\\n    for (int b : children[a]) {\\n        parent[b] = a;\\n        rootify(b);\\n        int hsub = highestSubtree[b].first + 1;\\n        if (hsub > h1) {\\n            h2 = h1;\\n            h1 = hsub;\\n        } else if (hsub > h2) {\\n            h2 = hsub;\\n        }\\n    }\\n    highestSubtree[a] = make_pair(h1, h2);\\n}\\n\\nint main() {\\n    while (cin >> N) {\\n        children.clear();\\n        children.resize(N + 1);\\n        for (int i = 0; i < N; i++) {\\n            int count; cin >> count;\\n            while (count--) {\\n                int a; cin >> a; a--;\\n                children[i].push_back(a);\\n            }\\n        }\\n\\n        parent[0] = 0;\\n        rootify(0);\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"4\": true,\n    \"className\": \"language-cpp\",\n    \"metastring\": \"4\"\n  }), \"vector<vector<int>> children;\\nint parent[5001];\\npair<int, int> highestSubtree[5001];\\nint upheight[5001];\\nint N;\\n\\nvoid rootify(int a) {\\n    auto it = find(children[a].begin(), children[a].end(), parent[a]);\\n    if (it != children[a].end()) {\\n        children[a].erase(it);\\n    }\\n\\n    int h1 = 0, h2 = 0;\\n    for (int b : children[a]) {\\n        parent[b] = a;\\n        rootify(b);\\n        int hsub = highestSubtree[b].first + 1;\\n        if (hsub > h1) {\\n            h2 = h1;\\n            h1 = hsub;\\n        } else if (hsub > h2) {\\n            h2 = hsub;\\n        }\\n    }\\n    highestSubtree[a] = make_pair(h1, h2);\\n}\\n\\nvoid compute_upheight(int a) {\\n    int h = highestSubtree[a].first + 1;\\n    if (a != 0) {\\n        int h1, h2;\\n        tie(h1, h2) = highestSubtree[parent[a]];\\n        if (h1 == h) h1 = h2;\\n        upheight[a] = 1 + max(upheight[parent[a]], h1);\\n    } else {\\n        upheight[a] = 0;\\n    }\\n\\n    for (int b : children[a]) {\\n        compute_upheight(b);\\n    }\\n}\\n\\nint height(int a) {\\n    return max(upheight[a], highestSubtree[a].first);\\n}\\n\\nint main() {\\n    while (cin >> N) {\\n        children.clear();\\n        children.resize(N + 1);\\n        for (int i = 0; i < N; i++) {\\n            int count; cin >> count;\\n            while (count--) {\\n                int a; cin >> a; a--;\\n                children[i].push_back(a);\\n            }\\n        }\\n\\n        parent[0] = 0;\\n        rootify(0);\\n        compute_upheight(0);\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"28,39:42\",\n    \"28,39:42\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"29\": true,\n    \"className\": \"language-diff\",\n    \"metastring\": \"29\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"31:33\",\n    \"31:33\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"34\": true,\n    \"className\": \"language-diff\",\n    \"metastring\": \"34\"\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"35:37\",\n    \"35:37\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"44:46\",\n    \"44:46\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"1:63\",\n    \"1:63\": true\n  }), \"\"))), mdx(\"hr\", null), mdx(GraphAnimation, {\n    directed: true,\n    graph: makeGraph([[1, 2], [2, 3], [1, 5, 'long'], [2, 5], [3, 4], [4, 6], [5, 4]], [1], 0.6),\n    steps: function steps(g) {\n      return [['reset']];\n    },\n    mdxType: \"GraphAnimation\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"matchPath":"/*","id":"ebd3cca4-6d1f-5c1f-a266-cc08803086b2","slug":"/graphs-intro","title":"Grafy"}},"staticQueryHashes":[]}