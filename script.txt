Okej, wprowadzenie do grafów.

Graf to jest taki abstrakcyjny objekt, który składa się z

wierzchołków

i krawędzi. Graf może reprezentować na przykład znajomości w serwisie społecznościowym
albo sieć dróg. Istnieje wiele gatunków grafów. Na przykład,

jeśli rozróżniamy początek od końca krawędzi, to mówimy o grafie skierowanym. Możemy
w ten sposób modelować na przykład drogi jednokierunkowe.

Do krawędzi możemy też przypisywać jakieś informacje. Jeśli są to liczby, to często
nazywamy je wagami. Mówimy wtedy o grafie ważonym.

Okej, ale jak to wygląda w pamięci komputera? Jest kilka popularnych opcji.

Po pierwsze mamy formę macierzy sąsiedztwa - tablica dwuwymiarowa, która zapamiętuje
czy między dwoma wierzchołkami istnieje krawędź.

Możemy łatwo i szybko sprawdzić czy dane wierzchołki są połączone krawędzią,

dodawanie krawędzi też jest proste. Obie operacje zajmują czas stały.

Natomiast jeśli mamy jakiś konkretny wierzchołek i chcemy poznać wszystkich jego sąsiadów,
to musimy sprawdzić wszystkie wierzchołki w grafie.

Złożoność pamięciowa też nie jest zbyt dobra, bo rzędu n².

Dlatego też macierz sąsiedztwa jest dobrym pomysłem raczej tylko wtedy, kiedy znaczący
ułamek wszystkich możliwych krawędzi jest w naszym grafie. W takich sytuacjach zwykle
wejście do programu będzie przyjmować postać przypominającą taką macierz.

Oczywiście, macierze sąsiedztwa możemy też dostosować do grafu skierowanego. Wystarczy
zdecydować się, który z indeksów stanowi początek krawędzi, a który koniec.

Grafy ważone też działają, wystarczy zmienić typ tablicy na int. Wtedy brak krawędzi
możemy oznaczać jakąś specjalną wartością typu 0, -1, albo 2 miliardy.

Możemy też zastosować typ optional.

Ale w ogólnym przypadku zamiast macierzy sąsiedztwa lepsze są listy sąsiedztwa:
dla każdego wierzchołka przechowujemy listę jego sąsiadów. Dodawanie krawędzi jest
również szybkie, bo mamy amortyzowany czas stały.

Iterowanie po sąsiadach wierzchołka jest teraz optymalne, bo zajmuje czas proporcjonalny
do ilości sąsiadów.

Natomiast sprawdzenie czy dane wierzchołki ze sobą sąsiadują już zajmuje trochę czasu,
bo musimy sprawdzić wszystkich sąsiadów.

Trzeba uważać na przypadek pesymistyczny, który wygląda mniej więcej tak,
jak takie słoneczko.

Oczywiście możemy próbować to mitygować,

na przykład patrząc od tej strony, która ma mniej sąsiadów.

Ale nie trudno jest skonstruować pesymistyczny przypadek nawet dla takiego kodu.

Dlatego jeśli potrzebujemy odpowiadać na pytania typu "czy pomiędzy tymi wierzchołkami
istnieje krawędź", to zamiast wektora powinniśmy zastosować coś typu set.

Sprawdzenie czy krawędź istnieje zajmuje wtedy czas logarytmiczny.

Jeśli nasz graf jest ważony, to zamiast seta możemy użyć mapy.

Jeśli graf jest skierowany, to najlepiej jest trzymać osobne listy dla początków
i końców krawędzi.

Jest jeszcze trzecia reprezentacja, która polega na tym, że grafu w ogóle nie trzymamy
w pamięci. Po angielsku nazywamy to implicit graph. Nie udało mi się znaleźć polskiego
terminu, ale można to nazwać grafem domniemanym. Chodzi o to, że informacje o krawędziach
można szybko obliczyć z jakiejś innej postaci. Dobrym przykładem są na przykład labirynty,
gdzie wystarczy sprawdzić, czy dane wierzchołki sąsiadują
i czy któryś z nich nie jest ścianą.

Okej, to jak mamy graf, to co możemy z nim zrobić? Bardzo często musimy w jakiś sposób
przejść po grafie. Można po prostu rekurencyjnie przejść po wierzchołkach, ale trzeba
uważać, aby nie wpaść w nieskończoną pętlę.

Na przykład, jeśli zaczniemy od dwójki i pójdziemy przez trójkę, czwórkę i piątkę,
to znajdziemy się znów w dwójce.

Taki ciag wierzchołków nazywamy cyklem. Aby obsłużyć cykle, trzeba pamiętać,
które z wierzchołków już odwiedziliśmy.

Takie rekurencyjne przejście grafu nazywamy przeszukiwaniem wgłąb lub Depth First Search.

Implementacja jest bardzo prosta - wystarczy tablica w której zapamiętujemy, czy
odwiedziliśmy dany wierzchołek, oraz krótka funkcja rekurencyjna. Ważne jest to, aby
zapisać aktualny wierzchołek w tablicy zanim zabierzemy się za przetwarzanie jego sąsiadów.
Oczywiście, to jest tylko szkielet implementacji, bo przechodząc przez graf nic nie robimy.
Reszta zależy od zadania.

Warto też wspomnieć, że w niektórych zadaniach będziemy musieli wyczyścić tablicę seen
pomiędzy wyszukaniami. Może się to okazać dość powolne.

Przydaje się tutaj taki trik: wywołaniom funkcji przypisujemy epoki --- kolejne liczby
całkowite. Wtedy w tablicy zapisujemy, w której epoce odwiedziliśmy dany wierzchołek,
i jako odwiedzone wierzchołki traktujemy tylko te, które mają zapisaną aktualną epokę.
Wtedy pomiędzy spacerami po grafie wystarczy tylko zainkrementować epokę.

Okej, to w takim razie czas na zadanie, na ekranie macie link do treści i przykładowego
wejścia, ale ja pozwolę sobie omówić treść.

Zadanie ma tytuł Forwarding Emails, i dotyczy łańcuszków emailowych. Ale z okazji
czwartkowego lądowania łazika Perseverance, zadanie dzieje się na Marsie --- a Marsjanie
mają dużo precyzyjniejszy sposób na radzenie sobie z łańcuszkami. Każdy Marsjanin
ma wybranego dokładnie jednego znajomego, do którego prześle łańcuszek.
My wcielamy się w wodza Marsjańskiego klanu, który chce rozpocząć łańcuszek tak, aby
dotarł on do jak najwięcej osób. Uparcie chcemy jednak wysłać go do jednej osoby.

W tym wypadku mamy pięć różnych opcji dla których mail dotrze do pięciu osób, ale
największa osiągalna liczba to 7. Wypisalibyśmy więc wierzchołek numer 1. Jest jeszcze
jedna zasada - jak jest remis, to wypisujemy marsjanina o najmniejszym numerze.

Proponuję by teraz każdy spróbował rozwiązać to zadanie.

Okej, weźmy sobie jakiś przykład w którym graf nie jest spójny.

Mamy tutaj dwie spójne składowe.

Nie trudno się przekonać, że każda spójna składowa grafu będzie się składać

z cyklu oraz

potencjalnych odnóg, które się z tym cyklem łączą.

Powiedzmy że puścimy sobie DFSa z wierzchołka pierwszego.

Przyda nam się tablica, w której zapiszemy wynik dla każdego wierzchołka.
